#!/bin/bash 
# Martin Ostermann, 2005-08-24
DEBUG=0

NewTitle="-"
NewShort="-"
NewLong="-"

function usage () {
	echo "Usage: $0 [-d] [-T <title>] [-S <shortDesc>] [-L <longDesc>] <cridfile>";
}

# handle command line options -- overrid defaults
while getopts "dhT:S:L:" opt ; do
        case $opt in
          d ) DEBUG=1 ;;
	  T ) NewTitle="$OPTARG" ;;
	  S ) NewShort="$OPTARG" ;;
	  L ) NewLong="$OPTARG" ;;
          h ) usage
              exit;;
        esac
done

if [ $# = $OPTIND ]; then
	shift $(( $# - 1 ))
	Cridfile=$1
else
	usage
fi



function debug () {
        if [ $DEBUG != 0 ] ; then
                echo $*
        fi
}

function hex_replace () {
	local s c New
	s=$(( $1 - $2 ))
	c=$2
	New="$3"
	c_New=${#New}
	debug $s $c_New $New
	if [ $c_New -gt 65535 ] ; then
		echo "Replacement text too long!" >/dev/stderr
		exit
	fi
	HEX_c=`printf "%%%02X%%%02X" "$(( c_New / 256 ))" "$(( c_New % 256 ))"`
	debug "HEX_c= $HEX_c"
	HEX_New=`echo -n "$New" | iso2post| sed -e 's/0A/8A/g'`
	debug HEX_New=$HEX_New
	HEX_Crid=`echo -n $HEX_Crid | sed -r \
		-e "s/((%..){$((s-2))})(%..){$((c+2))}/\1$HEX_c$HEX_New/" `
}		

declare -a Crid0
declare -a Crid1
declare -a Crid2
declare -a Crid3

Crid0=( `hexdump -n 50 -e '11/4 "%d \n" 1/2 "%d \n" 1/4 "%d \n" ' $Cridfile ` )
c1=${Crid0[12]}
s1=$(( 50 + $c1 )) 
n1=8

true #Title=`dd bs=1 skip=$(($s1-$c1)) count=$c1 2>/dev/null <$Cridfile`
RecordingStatus=${Crid0[3]}
Begin=${Crid0[4]}
End=${Crid0[5]}
RecordingFlag=${Crid0[9]}

Crid1=( `hexdump -s $s1 -n $n1 -e "2/4 \"%d \n\" " $Cridfile ` )
c2=${Crid1[1]}
s2=$(( $s1+$n1+$c2 ))

c3=$c2
s3=$s2

f=${Crid1[0]}
while [ $f != 0 ] ; do
	n2=24
	Crid2=( `hexdump -s $s2 -n $n2 -e "6/4 \"%d \n\" " $Cridfile `)
	c3=${Crid2[5]}
	s3=$(( $s2+$n2+$c3 ))
	s2=$s3
	c2=$c3
	f=$(($f-1))
done

if true ; then
	n3=4
	Crid3=( `hexdump -s $s3 -n $n3 -e "1/4 \"%d \n\" " $Cridfile `)
	c4=${Crid3[0]}
	s4=$(( $s3+$n3+$c4 ))
	n4=4

	#echo c1=$c1  c2=$c2  c3=$c3  c4=$c4
	#Crid4=( `hexdump -s $s4 -n $n4 -e "1/4 \"%d \n\" " $Cridfile` )

	if [ $c3 != 0 ]; then
		true #short=`hexdump -s $(($s3-$c3)) -n $c3 -e "1/${c3} \"%s\n\"" $Cridfile`
	fi
	if [ $c4 != 0 ]; then
		true #long=`hexdump -s $(($s4-$c4)) -n $c4 -e "1/${c4} \"%s\n\"" $Cridfile`
	fi
fi

if [ "$NewTitle" != "-" ] || [ "$NewShort" != "-" ] || [ "NewShort" != "-" ] ;then
	
	HEX_Crid=`iso2post <$Cridfile` 	
	if [ "$NewLong" != "-" ] ; then
		hex_replace $s4 $c4 "$NewLong"
	fi
	if [ "$NewShort" != "-" ] ; then
		hex_replace $s3 $c3 "$NewShort" 
	fi
	if [ "$NewTitle" != "-" ] ; then
		hex_replace $s1 $c1 "$NewTitle" 
	fi
	
	# patch to EPG Recording to get wavebox to show details... only for 
	# single manual timer/recordings 
	if [ $RecordingFlag -eq 2 ] ; then
		HEX_Crid=`echo -n $HEX_Crid | sed -r -e "s/((%..){39})(%..)/\1%01/" `
	fi
	
	#post2iso apparently fails for some (likely \0) characters
	hex=`echo "$HEX_Crid" | sed -e 's/[%]/\\\\x/g'`
	printf "$hex" >$Cridfile
fi
